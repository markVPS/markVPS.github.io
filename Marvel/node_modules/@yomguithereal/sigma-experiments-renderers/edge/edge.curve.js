"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var utils_1 = require("sigma/utils");
var edge_1 = require("sigma/rendering/webgl/programs/common/edge");
var VERTEX_SHADER_SOURCE = /*glsl*/ "\nattribute vec4 a_color;\nattribute float a_direction;\nattribute float a_thickness;\nattribute vec2 a_source;\nattribute vec2 a_target;\nattribute float a_current;\nattribute float a_curveness;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_pixelRatio;\nuniform vec2 u_dimensions;\n\nvarying vec4 v_color;\nvarying float v_thickness;\nvarying vec2 v_cpA;\nvarying vec2 v_cpB;\nvarying vec2 v_cpC;\n\nconst float bias = 255.0 / 254.0;\nconst float epsilon = 0.7;\nconst float minThickness = 0.3;\n\nvec2 clipspaceToViewport(vec2 pos, vec2 dimensions) {\n  return vec2(\n    (pos.x + 1.0) * dimensions.x / 2.0,\n    (pos.y + 1.0) * dimensions.y / 2.0\n  );\n}\n\nvec2 viewportToClipspace(vec2 pos, vec2 dimensions) {\n  return vec2(\n    pos.x / dimensions.x * 2.0 - 1.0,\n    pos.y / dimensions.y * 2.0 - 1.0\n  );\n}\n\nvoid main() {\n\n  // Selecting the correct position\n  // Branchless \"position = a_source if a_current == 1.0 else a_target\"\n  vec2 position = a_source * max(0.0, a_current) + a_target * max(0.0, 1.0 - a_current);\n  position = (u_matrix * vec3(position, 1)).xy;\n\n  vec2 source = (u_matrix * vec3(a_source, 1)).xy;\n  vec2 target = (u_matrix * vec3(a_target, 1)).xy;\n\n  vec2 viewportPosition = clipspaceToViewport(position, u_dimensions);\n  vec2 viewportSource = clipspaceToViewport(source, u_dimensions);\n  vec2 viewportTarget = clipspaceToViewport(target, u_dimensions);\n\n  vec2 delta = viewportTarget.xy - viewportSource.xy;\n  float len = length(delta);\n  vec2 normal = vec2(-delta.y, delta.x) * a_direction;\n  vec2 unitNormal = normal / len;\n  float boundingBoxThickness = len * a_curveness;\n  float curveThickness = max(minThickness, a_thickness / 2.0 / u_sizeRatio * u_pixelRatio);\n\n  v_thickness = curveThickness;\n\n  v_cpA = viewportSource;\n  v_cpB = 0.5 * (viewportSource + viewportTarget) + unitNormal * a_direction * boundingBoxThickness;\n  v_cpC = viewportTarget;\n\n  vec2 viewportOffsetPosition = (\n    viewportPosition +\n    unitNormal * (boundingBoxThickness / 2.0 + curveThickness + epsilon) *\n    max(0.0, a_direction) // NOTE: cutting the bounding box in half to avoid overdraw\n  );\n\n  position = viewportToClipspace(viewportOffsetPosition, u_dimensions);\n  gl_Position = vec4(position, 0, 1);\n\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";
var FRAGMENT_SHADER_SOURCE = /*glsl*/ "\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying float v_thickness;\nvarying vec2 v_cpA;\nvarying vec2 v_cpB;\nvarying vec2 v_cpC;\n\nfloat det(vec2 a, vec2 b) {\n  return a.x * b.y - b.x * a.y;\n}\n\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a = det(b0, b2), b = 2.0 * det(b1, b0), d = 2.0 * det(b2, b1);\n  float f = b * d - a * a;\n  vec2 d21 = b2 - b1, d10 = b1 - b0, d20 = b2 - b0;\n  vec2 gf = 2.0 * (b * d21 + d * d10 + a * d20);\n  gf = vec2(gf.y, -gf.x);\n  vec2 pp = -f * gf / dot(gf, gf);\n  vec2 d0p = b0 - pp;\n  float ap = det(d0p, d20), bp = 2.0 * det(d10, d0p);\n  float t = clamp((ap + bp) / (2.0 * a + b + d), 0.0, 1.0);\n  return mix(mix(b0, b1, t), mix(b1, b2, t), t);\n}\n\nfloat distToQuadraticBezierCurve(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0 - p, b1 - p, b2 - p));\n}\n\nconst float epsilon = 0.7;\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  float dist = distToQuadraticBezierCurve(gl_FragCoord.xy, v_cpA, v_cpB, v_cpC);\n\n  if (dist < v_thickness + epsilon) {\n    float inCurve = 1.0 - smoothstep(v_thickness - epsilon, v_thickness + epsilon, dist);\n    gl_FragColor = inCurve * vec4(v_color.rgb * v_color.a, v_color.a);\n  } else {\n    gl_FragColor = transparent;\n  }\n}\n";
var UNSIGNED_BYTE = WebGLRenderingContext.UNSIGNED_BYTE, FLOAT = WebGLRenderingContext.FLOAT;
var UNIFORMS = ["u_matrix", "u_sizeRatio", "u_dimensions", "u_pixelRatio"];
var DEFAULT_EDGE_CURVENESS = 0.25;
var EdgeCurveProgram = /** @class */ (function (_super) {
    __extends(EdgeCurveProgram, _super);
    function EdgeCurveProgram() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EdgeCurveProgram.prototype.getDefinition = function () {
        return {
            VERTICES: 4,
            ARRAY_ITEMS_PER_VERTEX: 9,
            VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,
            FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,
            UNIFORMS: UNIFORMS,
            ATTRIBUTES: [
                { name: "a_source", size: 2, type: FLOAT },
                { name: "a_target", size: 2, type: FLOAT },
                { name: "a_current", size: 1, type: FLOAT },
                { name: "a_color", size: 4, type: UNSIGNED_BYTE, normalized: true },
                { name: "a_direction", size: 1, type: FLOAT },
                { name: "a_thickness", size: 1, type: FLOAT },
                { name: "a_curveness", size: 1, type: FLOAT },
            ]
        };
    };
    EdgeCurveProgram.prototype.reallocateIndices = function () {
        var l = this.verticesCount;
        var size = l + l / 2;
        var indices = new this.IndicesArray(size);
        for (var i = 0, c = 0; i < l; i += 4) {
            indices[c++] = i;
            indices[c++] = i + 1;
            indices[c++] = i + 2;
            indices[c++] = i + 2;
            indices[c++] = i + 1;
            indices[c++] = i + 3;
        }
        this.indicesArray = indices;
    };
    EdgeCurveProgram.prototype.processVisibleItem = function (i, sourceData, targetData, data) {
        var thickness = data.size || 1;
        var x1 = sourceData.x;
        var y1 = sourceData.y;
        var x2 = targetData.x;
        var y2 = targetData.y;
        var color = (0, utils_1.floatColor)(data.color);
        var curveness = typeof data.curveness === "number" ? data.curveness : DEFAULT_EDGE_CURVENESS;
        var array = this.array;
        // First point
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = 0;
        array[i++] = color;
        array[i++] = 1;
        array[i++] = thickness;
        array[i++] = curveness;
        // First point flipped
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = 0;
        array[i++] = color;
        array[i++] = -1;
        array[i++] = thickness;
        array[i++] = curveness;
        // Second point
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = 1;
        array[i++] = color;
        array[i++] = 1;
        array[i++] = thickness;
        array[i++] = curveness;
        // Second point flipped
        array[i++] = x1;
        array[i++] = y1;
        array[i++] = x2;
        array[i++] = y2;
        array[i++] = 1;
        array[i++] = color;
        array[i++] = -1;
        array[i++] = thickness;
        array[i++] = curveness;
    };
    EdgeCurveProgram.prototype.draw = function (params) {
        var gl = this.gl;
        var _a = this.uniformLocations, u_matrix = _a.u_matrix, u_sizeRatio = _a.u_sizeRatio, u_dimensions = _a.u_dimensions, u_pixelRatio = _a.u_pixelRatio;
        gl.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl.uniform1f(u_pixelRatio, params.pixelRatio);
        gl.uniform1f(u_sizeRatio, params.sizeRatio);
        gl.uniform2f(u_dimensions, params.width * params.pixelRatio, params.height * params.pixelRatio);
        if (!this.indicesArray)
            throw new Error("EdgeCurveProgram: indicesArray should be allocated when drawing!");
        gl.drawElements(gl.TRIANGLES, this.indicesArray.length, this.indicesType, 0);
    };
    return EdgeCurveProgram;
}(edge_1.EdgeProgram));
exports["default"] = EdgeCurveProgram;
