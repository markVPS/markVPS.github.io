"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var node_1 = require("sigma/rendering/webgl/programs/common/node");
var node_circle_1 = __importDefault(require("sigma/rendering/webgl/programs/node.circle"));
var utils_1 = require("sigma/utils");
var VERTEX_SHADER_SOURCE = /*glsl*/ "\nattribute vec2 a_position;\nattribute float a_size;\nattribute float a_angle;\nattribute vec4 a_color;\nattribute float a_intensity;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\nuniform float u_ignoreZoom;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\nvarying float v_border;\nvarying float v_intensity;\n\nconst float bias = 255.0 / 254.0;\nconst float marginRatio = 1.05;\n\nvoid main() {\n  float size = a_size * u_correctionRatio / u_sizeRatio * u_ignoreZoom * 4.0;\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\n  vec2 position = a_position + diffVector * marginRatio;\n  gl_Position = vec4(\n    (u_matrix * vec3(position, 1)).xy,\n    0,\n    1\n  );\n\n  v_border = u_correctionRatio;\n  v_diffVector = diffVector;\n  v_radius = size / 2.0 / marginRatio;\n\n  v_color = a_color;\n  v_color.a *= bias;\n\n  v_intensity = a_intensity;\n}\n";
var FRAGMENT_SHADER_SOURCE = /*glsl*/ "\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\nvarying float v_border;\nvarying float v_intensity;\n\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  float dist = length(v_diffVector);\n  float intensity = v_intensity * (1.0 - dist);\n\n  if (dist < v_radius) {\n    gl_FragColor = mix(v_color, transparent, pow(dist / v_radius, intensity));\n  }\n  else {\n    gl_FragColor = transparent;\n  }\n}\n";
var UNIFORMS = ["u_sizeRatio", "u_correctionRatio", "u_matrix", "u_ignoreZoom"];
var FLOAT = WebGLRenderingContext.FLOAT, UNSIGNED_BYTE = WebGLRenderingContext.UNSIGNED_BYTE;
var NodeHaloProgram = /** @class */ (function (_super) {
    __extends(NodeHaloProgram, _super);
    function NodeHaloProgram() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NodeHaloProgram.prototype.getDefinition = function () {
        return {
            VERTICES: 3,
            ARRAY_ITEMS_PER_VERTEX: 6,
            VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,
            FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,
            UNIFORMS: UNIFORMS,
            ATTRIBUTES: [
                { name: "a_position", size: 2, type: FLOAT },
                { name: "a_size", size: 1, type: FLOAT },
                { name: "a_color", size: 4, type: UNSIGNED_BYTE, normalized: true },
                { name: "a_angle", size: 1, type: FLOAT },
                { name: "a_intensity", size: 1, type: FLOAT },
            ]
        };
    };
    NodeHaloProgram.prototype.processVisibleItem = function (i, data) {
        var array = this.array;
        var color = (0, utils_1.floatColor)(data.haloColor || data.color);
        var intensity = typeof data.haloIntensity === "number" ? data.haloIntensity : 1;
        var size = Math.max(typeof data.haloSize === "number" ? data.haloSize : 0, data.size);
        array[i++] = data.x;
        array[i++] = data.y;
        array[i++] = size;
        array[i++] = color;
        array[i++] = node_circle_1["default"].ANGLE_1;
        array[i++] = intensity;
        array[i++] = data.x;
        array[i++] = data.y;
        array[i++] = size;
        array[i++] = color;
        array[i++] = node_circle_1["default"].ANGLE_2;
        array[i++] = intensity;
        array[i++] = data.x;
        array[i++] = data.y;
        array[i++] = size;
        array[i++] = color;
        array[i++] = node_circle_1["default"].ANGLE_3;
        array[i++] = intensity;
    };
    NodeHaloProgram.prototype.draw = function (params) {
        var gl = this.gl;
        var _a = this.uniformLocations, u_sizeRatio = _a.u_sizeRatio, u_correctionRatio = _a.u_correctionRatio, u_matrix = _a.u_matrix, u_ignoreZoom = _a.u_ignoreZoom;
        gl.uniform1f(u_ignoreZoom, 1);
        // NOTE: uncomment next line to disable zoom impact.
        // gl.uniform1f(u_ignoreZoom, 1 / params.sizeRatio);
        gl.uniform1f(u_sizeRatio, params.sizeRatio);
        gl.uniform1f(u_correctionRatio, params.correctionRatio);
        gl.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl.drawArrays(gl.TRIANGLES, 0, this.verticesCount);
    };
    return NodeHaloProgram;
}(node_1.NodeProgram));
exports["default"] = NodeHaloProgram;
