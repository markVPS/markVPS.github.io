"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var utils_1 = require("sigma/utils");
var node_1 = require("sigma/rendering/webgl/programs/common/node");
var DEFAULT_CREATE_NODE_PICTOGRAM_OPTIONS = {
    correctCentering: false,
    forcedSvgSize: undefined,
    keepWithinCircle: true
};
var VERTEX_SHADER_SOURCE = /*glsl*/ "\nattribute vec2 a_position;\nattribute float a_size;\nattribute vec4 a_color;\nattribute vec4 a_texture;\n\nuniform float u_sizeRatio;\nuniform float u_pixelRatio;\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\nvarying float v_border;\nvarying vec4 v_texture;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  // Multiply the point size twice:\n  //  - x SCALING_RATIO to correct the canvas scaling\n  //  - x 2 to correct the formulae\n  gl_PointSize = a_size / u_sizeRatio * u_pixelRatio * 2.0;\n\n  v_border = (0.5 / a_size) * u_sizeRatio;\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n\n  // Pass the texture coordinates:\n  // NOTE: multiply a_texture by a constant and you get a pattern\n  v_texture = a_texture;\n}\n";
var FRAGMENT_SHADER_SOURCE = /*glsl*/ "\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying float v_border;\nvarying vec4 v_texture;\n\nuniform sampler2D u_atlas;\nuniform float u_keepWithinCircle;\n\nconst float radius = 0.5;\n\nvoid main(void) {\n  vec4 texel = texture2D(u_atlas, v_texture.xy + gl_PointCoord * v_texture.zw, -1.0);\n  vec4 color = mix(gl_FragColor, v_color, texel.a);\n\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\n  float dist = length(m) * u_keepWithinCircle;\n\n  if (dist < radius - v_border) {\n    gl_FragColor = color;\n  }\n}\n";
// maximum size of single texture in atlas
var MAX_TEXTURE_SIZE = Infinity;
// maximum width of atlas texture (limited by browser)
// low setting of 3072 works on phones & tablets
var MAX_CANVAS_WIDTH = 3072;
// Helper class able to "correct" the centering of a svg pictogram by
// finding the "true" visually correct center through the barycenter of the
// pictogram's alpha layer in x and y dimension.
var PictogramCenteringCorrector = /** @class */ (function () {
    function PictogramCenteringCorrector() {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
    }
    PictogramCenteringCorrector.prototype.getCorrectionOffset = function (image, size) {
        this.canvas.width = size;
        this.canvas.height = size;
        this.context.clearRect(0, 0, size, size);
        this.context.drawImage(image, 0, 0, size, size);
        var data = this.context.getImageData(0, 0, size, size).data;
        var alpha = new Uint8ClampedArray(data.length / 4);
        for (var i = 0; i < data.length; i++) {
            alpha[i] = data[i * 4 + 3];
        }
        var sumX = 0;
        var sumY = 0;
        var total = 0;
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                var a = alpha[y * size + x];
                total += a;
                sumX += a * x;
                sumY += a * y;
            }
        }
        var barycenterX = sumX / total;
        var barycenterY = sumY / total;
        return {
            x: barycenterX - size / 2,
            y: barycenterY - size / 2
        };
    };
    return PictogramCenteringCorrector;
}());
/**
 * To share the texture between the program instances of the graph and the
 * hovered nodes (to prevent some flickering, mostly), this program must be
 * "built" for each sigma instance:
 */
function createNodePictogramProgram(options) {
    options = Object.assign({}, DEFAULT_CREATE_NODE_PICTOGRAM_OPTIONS, options);
    var keepWithinCircle = options.keepWithinCircle !== false;
    var corrector = new PictogramCenteringCorrector();
    /**
     * These attributes are shared between all instances of this exact class,
     * returned by this call to getNodeProgramImage:
     */
    var rebindTextureFns = [];
    var images = {};
    var textureImage;
    var hasReceivedImages = false;
    var pendingImagesFrameID = undefined;
    // next write position in texture
    var writePositionX = 0;
    var writePositionY = 0;
    // height of current row
    var writeRowHeight = 0;
    /**
     * Helper to load an image:
     */
    function loadImage(imageSource) {
        if (images[imageSource])
            return;
        var forcedSvgSize = options === null || options === void 0 ? void 0 : options.forcedSvgSize;
        // If forcing a SVG size (typically to oversample the resulting rasterized
        // size so that the icon is crispier), we fetch the svg string and we
        // mangle it to force a certain size and view box.
        // Of course this cannot work if said SVG cannot be access through CORS.
        if (forcedSvgSize) {
            images[imageSource] = { status: "loading" };
            fetch(imageSource)
                .then(function (r) { return r.text(); })
                .then(function (svgString) {
                var svg = new DOMParser().parseFromString(svgString, "image/svg+xml");
                var root = svg.documentElement;
                var originalWidth = root.getAttribute("width");
                var originalHeight = root.getAttribute("height");
                if (!originalWidth || !originalHeight)
                    throw new Error("createNodePictogramProgram.loadImage: cannot use `forcedSvgSize` if target svg has no definite dimensions.");
                root.setAttribute("width", "" + forcedSvgSize);
                root.setAttribute("height", "" + forcedSvgSize);
                root.setAttribute("viewBox", "0 0 ".concat(originalWidth, " ").concat(originalHeight));
                var correctedSvgString = new XMLSerializer().serializeToString(svg);
                var blob = new Blob([correctedSvgString], { type: "image/svg+xml" });
                var url = URL.createObjectURL(blob);
                var svgImage = new Image();
                svgImage.src = url;
                svgImage.addEventListener("load", function () {
                    images[imageSource] = {
                        status: "pending",
                        image: svgImage
                    };
                    if (typeof pendingImagesFrameID !== "number") {
                        pendingImagesFrameID = requestAnimationFrame(function () { return finalizePendingImages(); });
                    }
                    URL.revokeObjectURL(url);
                }, { once: true });
            })["catch"](function () {
                images[imageSource] = { status: "error" };
            });
            return;
        }
        var image = new Image();
        image.addEventListener("load", function () {
            images[imageSource] = {
                status: "pending",
                image: image
            };
            if (typeof pendingImagesFrameID !== "number") {
                pendingImagesFrameID = requestAnimationFrame(function () { return finalizePendingImages(); });
            }
        });
        image.addEventListener("error", function () {
            images[imageSource] = { status: "error" };
        });
        images[imageSource] = { status: "loading" };
        // Load image:
        image.setAttribute("crossOrigin", "");
        image.src = imageSource;
    }
    /**
     * Helper that takes all pending images and adds them into the texture:
     */
    function finalizePendingImages() {
        pendingImagesFrameID = undefined;
        var pendingImages = [];
        // List all pending images:
        for (var id in images) {
            var state = images[id];
            if (state.status === "pending") {
                pendingImages.push({
                    id: id,
                    image: state.image,
                    size: Math.min(state.image.width, state.image.height) || 1
                });
            }
        }
        // Add images to texture:
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d", { willReadFrequently: true });
        // limit canvas size to avoid browser and platform limits
        var totalWidth = hasReceivedImages ? textureImage.width : 0;
        var totalHeight = hasReceivedImages ? textureImage.height : 0;
        // initialize image drawing offsets with current write position
        var xOffset = writePositionX;
        var yOffset = writePositionY;
        /**
         * Draws a (full or partial) row of images into the atlas texture
         * @param pendingImages
         */
        var drawRow = function (pendingImages) {
            // update canvas size before drawing
            if (canvas.width !== totalWidth || canvas.height !== totalHeight) {
                canvas.width = Math.min(MAX_CANVAS_WIDTH, totalWidth);
                canvas.height = totalHeight;
                // draw previous texture into resized canvas
                if (hasReceivedImages) {
                    ctx.putImageData(textureImage, 0, 0);
                }
            }
            pendingImages.forEach(function (_a) {
                var id = _a.id, image = _a.image, size = _a.size;
                var imageSizeInTexture = Math.min(MAX_TEXTURE_SIZE, size);
                // Crop image, to only keep the biggest square, centered:
                var dx = 0, dy = 0;
                if ((image.width || 0) > (image.height || 0)) {
                    dx = (image.width - image.height) / 2;
                }
                else {
                    dy = (image.height - image.width) / 2;
                }
                var dxOffset = 0;
                var dyOffset = 0;
                if (options === null || options === void 0 ? void 0 : options.correctCentering) {
                    var correction = corrector.getCorrectionOffset(image, size);
                    dxOffset = correction.x;
                    dyOffset = correction.y;
                }
                // NOTE: it's possible to offset the image here, this is potentially useful for some pictograms
                ctx.drawImage(image, dx + dxOffset, dy + dyOffset, size, size, xOffset, yOffset, imageSizeInTexture, imageSizeInTexture);
                // Update image state:
                images[id] = {
                    status: "ready",
                    x: xOffset,
                    y: yOffset,
                    width: imageSizeInTexture,
                    height: imageSizeInTexture
                };
                xOffset += imageSizeInTexture;
            });
            hasReceivedImages = true;
            textureImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
        };
        var rowImages = [];
        pendingImages.forEach(function (image) {
            var size = image.size;
            var imageSizeInTexture = Math.min(size, MAX_TEXTURE_SIZE);
            if (writePositionX + imageSizeInTexture > MAX_CANVAS_WIDTH) {
                // existing row is full: flush row and continue on next line
                if (rowImages.length > 0) {
                    totalWidth = Math.max(writePositionX, totalWidth);
                    totalHeight = Math.max(writePositionY + writeRowHeight, totalHeight);
                    drawRow(rowImages);
                    rowImages = [];
                    writeRowHeight = 0;
                }
                writePositionX = 0;
                writePositionY = totalHeight;
                xOffset = 0;
                yOffset = totalHeight;
            }
            // add image to row
            rowImages.push(image);
            // advance write position and update maximum row height
            writePositionX += imageSizeInTexture;
            writeRowHeight = Math.max(writeRowHeight, imageSizeInTexture);
        });
        // flush pending images in row - keep write position (and drawing cursor)
        totalWidth = Math.max(writePositionX, totalWidth);
        totalHeight = Math.max(writePositionY + writeRowHeight, totalHeight);
        drawRow(rowImages);
        rowImages = [];
        rebindTextureFns.forEach(function (fn) { return fn(); });
    }
    var UNSIGNED_BYTE = WebGLRenderingContext.UNSIGNED_BYTE, FLOAT = WebGLRenderingContext.FLOAT;
    var UNIFORMS = ["u_sizeRatio", "u_pixelRatio", "u_matrix", "u_atlas", "u_keepWithinCircle"];
    return /** @class */ (function (_super) {
        __extends(NodePictogramProgram, _super);
        function NodePictogramProgram(gl, renderer) {
            var _this = _super.call(this, gl, renderer) || this;
            rebindTextureFns.push(function () {
                if (_this && _this.rebindTexture)
                    _this.rebindTexture();
                if (renderer && renderer.scheduleRefresh)
                    renderer.scheduleRefresh();
            });
            _this.texture = gl.createTexture();
            if (!textureImage) {
                textureImage = new ImageData(1, 1);
                gl.bindTexture(gl.TEXTURE_2D, _this.texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0]));
            }
            else {
                _this.rebindTexture();
            }
            return _this;
        }
        NodePictogramProgram.prototype.getDefinition = function () {
            return {
                VERTICES: 1,
                ARRAY_ITEMS_PER_VERTEX: 8,
                VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,
                FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,
                UNIFORMS: UNIFORMS,
                ATTRIBUTES: [
                    { name: "a_position", size: 2, type: FLOAT },
                    { name: "a_size", size: 1, type: FLOAT },
                    { name: "a_color", size: 4, type: UNSIGNED_BYTE, normalized: true },
                    { name: "a_texture", size: 4, type: FLOAT },
                ]
            };
        };
        NodePictogramProgram.prototype.rebindTexture = function () {
            var gl = this.gl;
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);
            gl.generateMipmap(gl.TEXTURE_2D);
            if (this.latestRenderParams)
                this.render(this.latestRenderParams);
        };
        NodePictogramProgram.prototype.processVisibleItem = function (i, data) {
            var array = this.array;
            var imageSource = data.pictogram;
            var imageState = imageSource && images[imageSource];
            if (typeof imageSource === "string" && !imageState)
                loadImage(imageSource);
            array[i++] = data.x;
            array[i++] = data.y;
            array[i++] = data.size;
            array[i++] = (0, utils_1.floatColor)(data.pictogramColor || "black");
            // Reference texture:
            if (imageState && imageState.status === "ready") {
                var width = textureImage.width, height = textureImage.height;
                array[i++] = imageState.x / width;
                array[i++] = imageState.y / height;
                array[i++] = imageState.width / width;
                array[i++] = imageState.height / height;
            }
            else {
                array[i++] = 0;
                array[i++] = 0;
                array[i++] = 0;
                array[i++] = 0;
            }
        };
        NodePictogramProgram.prototype.draw = function (params) {
            this.latestRenderParams = params;
            var gl = this.gl;
            var _a = this.uniformLocations, u_sizeRatio = _a.u_sizeRatio, u_pixelRatio = _a.u_pixelRatio, u_matrix = _a.u_matrix, u_atlas = _a.u_atlas, u_keepWithinCircle = _a.u_keepWithinCircle;
            gl.uniform1f(u_keepWithinCircle, keepWithinCircle ? 1 : 0);
            gl.uniform1f(u_sizeRatio, params.sizeRatio);
            gl.uniform1f(u_pixelRatio, params.pixelRatio);
            gl.uniformMatrix3fv(u_matrix, false, params.matrix);
            gl.uniform1i(u_atlas, 0);
            gl.drawArrays(gl.POINTS, 0, this.verticesCount);
        };
        return NodePictogramProgram;
    }(node_1.NodeProgram));
}
exports["default"] = createNodePictogramProgram;
