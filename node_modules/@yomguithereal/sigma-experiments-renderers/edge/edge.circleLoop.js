"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var node_circle_1 = __importDefault(require("sigma/rendering/webgl/programs/node.circle"));
var edge_1 = require("sigma/rendering/webgl/programs/common/edge");
var utils_1 = require("sigma/utils");
var VERTEX_SHADER_SOURCE = /*glsl*/ "\nattribute vec2 a_position;\nattribute float a_size;\nattribute float a_thickness;\nattribute float a_triangleVertexangle;\nattribute float a_loopAngle;\nattribute vec4 a_color;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\nvarying float v_border;\nvarying float v_borderRatio;\n\nconst float bias = 255.0 / 254.0;\nconst float marginRatio = 1.05;\nconst float minThickness = 0.5;\n\nvoid main() {\n  float size = a_size * u_correctionRatio / u_sizeRatio * 4.0;\n  vec2 diffVector = size * vec2(cos(a_triangleVertexangle), sin(a_triangleVertexangle));\n  vec2 position = (\n    a_position +\n    diffVector * marginRatio +\n    vec2(size / 2.0, size / 2.0) * vec2(cos(a_loopAngle), sin(a_loopAngle))\n  );\n\n  gl_Position = vec4(\n    (u_matrix * vec3(position, 1)).xy,\n    0,\n    1\n  );\n\n  v_border = u_correctionRatio;\n  v_borderRatio = 1.0 - max(minThickness, a_thickness) / a_size;\n  v_diffVector = diffVector;\n  v_radius = size / 2.0 / marginRatio;\n\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";
var FRAGMENT_SHADER_SOURCE = /*glsl*/ "\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\nvarying float v_border;\nvarying float v_borderRatio;\n\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  float borderRadius = v_borderRatio * v_radius;\n  float distToCenter = length(v_diffVector);\n\n  // Out of disc\n  if (distToCenter < borderRadius - v_border) {\n    gl_FragColor = transparent;\n  }\n  // Antialiasing between outside and border\n  else if (distToCenter < borderRadius) {\n    gl_FragColor = mix(v_color, transparent, (borderRadius - distToCenter) / v_border);\n  }\n  // Border\n  else if (distToCenter < v_radius - v_border) {\n    gl_FragColor = v_color;\n  }\n  // Antialiasing between border and transparent middle\n  else if (distToCenter < v_radius) {\n    gl_FragColor = mix(transparent, v_color, (v_radius - distToCenter) / v_border);\n  }\n  // Else\n  else {\n    gl_FragColor = transparent;\n  }\n}\n\n";
var UNIFORMS = ["u_sizeRatio", "u_correctionRatio", "u_matrix"];
var FLOAT = WebGLRenderingContext.FLOAT, UNSIGNED_BYTE = WebGLRenderingContext.UNSIGNED_BYTE;
var EdgeCircleLoopProgram = /** @class */ (function (_super) {
    __extends(EdgeCircleLoopProgram, _super);
    function EdgeCircleLoopProgram() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EdgeCircleLoopProgram.prototype.getDefinition = function () {
        return {
            VERTICES: 3,
            ARRAY_ITEMS_PER_VERTEX: 7,
            VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,
            FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,
            UNIFORMS: UNIFORMS,
            ATTRIBUTES: [
                { name: "a_position", size: 2, type: FLOAT },
                { name: "a_size", size: 1, type: FLOAT },
                { name: "a_thickness", size: 1, type: FLOAT },
                { name: "a_color", size: 4, type: UNSIGNED_BYTE, normalized: true },
                { name: "a_triangleVertexangle", size: 1, type: FLOAT },
                { name: "a_loopAngle", size: 1, type: FLOAT },
            ]
        };
    };
    EdgeCircleLoopProgram.prototype.processVisibleItem = function (i, sourceData, targetData, data) {
        var array = this.array;
        var color = (0, utils_1.floatColor)(data.color);
        var offset = typeof data.offset === "number" ? data.offset : 0;
        var loopSize = sourceData.size + offset;
        var loopAngle = typeof data.angle === "number" ? data.angle : EdgeCircleLoopProgram.UPPER_LEFT_ANGLE;
        // TODO: edge thickness should not overcome source size - 1 else it is basically ugly
        array[i++] = sourceData.x;
        array[i++] = sourceData.y;
        array[i++] = loopSize;
        array[i++] = data.size;
        array[i++] = color;
        array[i++] = node_circle_1["default"].ANGLE_1;
        array[i++] = loopAngle;
        array[i++] = sourceData.x;
        array[i++] = sourceData.y;
        array[i++] = loopSize;
        array[i++] = data.size;
        array[i++] = color;
        array[i++] = node_circle_1["default"].ANGLE_2;
        array[i++] = loopAngle;
        array[i++] = sourceData.x;
        array[i++] = sourceData.y;
        array[i++] = loopSize;
        array[i++] = data.size;
        array[i++] = color;
        array[i++] = node_circle_1["default"].ANGLE_3;
        array[i++] = loopAngle;
    };
    EdgeCircleLoopProgram.prototype.draw = function (params) {
        var gl = this.gl;
        var _a = this.uniformLocations, u_sizeRatio = _a.u_sizeRatio, u_correctionRatio = _a.u_correctionRatio, u_matrix = _a.u_matrix;
        gl.uniform1f(u_sizeRatio, params.sizeRatio);
        gl.uniform1f(u_correctionRatio, params.correctionRatio);
        gl.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl.drawArrays(gl.TRIANGLES, 0, this.verticesCount);
    };
    EdgeCircleLoopProgram.UPPER_LEFT_ANGLE = (3 * Math.PI) / 4;
    return EdgeCircleLoopProgram;
}(edge_1.EdgeProgram));
exports["default"] = EdgeCircleLoopProgram;
